# Android RE native libraries cheatsheet:

Notes taken from [Maddie Stone's workshop](https://github.com/maddiestone/AndroidAppRE "Maddie Stone's workshop")

To load Native libraries developers use:
//for a library called "libcalc.so" 
```System.loadLibrary("calc")``` <-- The system automatically determines the architecture used.
or
```System.load("lib/armeabi/libcalc.so")``` <-- note the full path. in this case the developer needs to choose the version of the library compiled for the righ architecture.

Once the "load"/"loadLibrary" methods are called in the Java code, the method "JNI_OnLoad" in the Native library is executed (if it exists).

To execute a native function, there has to be a method declared in the java code that maps to the native function. These methods are declared as follows:
```
public native String doThingsInNativeLibrary(int var0);
```

### Native to Java method linking/pairing is done in two ways:

- Dynamic Linking using JNI Native Method Name Resolving:

For native method:
public native String doThingsInNativeLibrary(int var0);

defined in class: com.android.package.class

```
Java_com_android_package_class_doThingsInNativeLibrary
```

** If you don't find the function linked in the native library (as above), then the developer is using static linking **

- Static Linking using the RegisterNatives API call

The developer must use the function "RegisterNatives" in the native code before trying to execute a native function (otherwise the JNI won't be able to find the function)

### Declaration of RegisterNatives:

```
jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);
```
Note the JNINativeMethod parameter above. This is where the name of the java methods and native functions are passed. (This is how you map java methods with Native functions). The structure of JNINativeMethod is:
```
The structure of 
typedef struct { 
    char *name; //<-- The Java method name
    char *signature; // <- The signature of the native function
    void *fnPtr; 
} JNINativeMethod;
```

Native function signature types:

    Z: boolean
    B: byte
    C: char
    S: short
    I: int
    J: long
    F: float
    D: double
    L fully-qualified-class ; :fully-qualified-class
    [ type: type[]
    ( arg-types ) ret-type: method type
    V: void

Examples:
public native long f (int n, String s, int[] arr); 

Type signature:
(ILjava/lang/String;[I)J

Note the info inside the parenthesis are the function's params
The first param is an int, represented as "I"
Second param is a String and it is represented as: "Ljava/lang/String;"
The third param is an array of int, represented as "[I"
Then after the parenthesis we find the return type. In the example it is "J" (long type)




